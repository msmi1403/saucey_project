rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // === User Profile Document and its Subcollections ===
    match /users/{userId} {
      allow get: if request.auth != null && request.auth.uid == userId;
      allow list: if request.auth != null && request.auth.uid == userId; // For subcollections

      // CREATE User Document
      allow create: if request.auth != null &&
                      request.auth.uid == userId &&
                      (request.resource.data.creationDate == request.time || request.resource.data.creationDate is timestamp) &&
                      (request.resource.data.username == null || request.resource.data.username_lowercase == request.resource.data.username.lower()) &&
                      (request.resource.data.followerCount == null || request.resource.data.followerCount == 0) &&
                      (request.resource.data.followingCount == null || request.resource.data.followingCount == 0) &&
                      (request.resource.data.preferredRecipeDifficulty == null || request.resource.data.preferredRecipeDifficulty is string) &&
                      (request.resource.data.preferredMaxCookTime == null || request.resource.data.preferredMaxCookTime is string) &&
                      (request.resource.data.preferredChefPersonality == null || request.resource.data.preferredChefPersonality is string) &&
                      request.resource.data.keys().hasOnly([
                        'firstName', 'lastName', 'username', 'phoneNumber', 'photoURL',
                        'creationDate', 'selectedDietaryFilters', 'customDietaryNotes',
                        'username_lowercase', 'bio', 'instagramUrl', 'youtubeUrl', 'tiktokUrl',
                        'featuredRecipeIds', 'followerCount', 'followingCount', 'badges',
                        'preferredRecipeDifficulty', 'preferredMaxCookTime', 'preferredChefPersonality',
                        'fcmTokens' // Added fcmTokens here
                      ]);

      // UPDATE User Document
      allow update: if request.auth != null && request.auth.uid == userId &&
                      // Ensure critical immutable fields are not changed by client if they are part of the update request.
                      // If these fields are NOT in the request.resource.data, these conditions automatically pass.
                      (!('creationDate' in request.resource.data) || request.resource.data.creationDate == resource.data.creationDate) &&
                      (!('followerCount' in request.resource.data) || request.resource.data.followerCount == resource.data.followerCount) &&
                      (!('followingCount' in request.resource.data) || request.resource.data.followingCount == resource.data.followingCount) &&

                      // Ensure username_lowercase is consistent if username is being updated.
                      // If username is not in the request, this whole block passes.
                      // If username IS in the request, then username_lowercase must also be in the request and be correct.
                      (
                        !('username' in request.resource.data) ||
                        (
                          'username_lowercase' in request.resource.data &&
                          request.resource.data.username_lowercase == request.resource.data.username.lower()
                        )
                      );
                      // By not having keys().hasOnly(), other fields are allowed to be updated (e.g. notificationPreferences).
                      // If you have fields that should NEVER be updated by the client after creation (e.g., a special role field),
                      // you would add specific denials here like: && !('sensitiveField' in request.resource.data)

      allow delete: if false; // Typically users don't delete their own accounts directly via client

      match /shopping_history/{historyId} {
        allow create: if request.auth != null &&
                        request.auth.uid == userId &&
                        request.resource.data.userId == request.auth.uid &&
                        request.resource.data.ingredientName is string &&
                        request.resource.data.checkedOffDate is timestamp &&
                        request.resource.data.addedToCartDate is timestamp &&
                        request.resource.data.isManuallyAdded is bool &&
                        (!('quantity' in request.resource.data) || request.resource.data.quantity is number || request.resource.data.quantity == null) &&
                        (!('unit' in request.resource.data) || request.resource.data.unit is string || request.resource.data.unit == null) &&
                        (!('storeSection' in request.resource.data) || request.resource.data.storeSection is string || request.resource.data.storeSection == null) &&
                        (!('originalRecipeId' in request.resource.data) || request.resource.data.originalRecipeId is string || request.resource.data.originalRecipeId == null) &&
                        (!('originalRecipeTitle' in request.resource.data) || request.resource.data.originalRecipeTitle is string || request.resource.data.originalRecipeTitle == null);
        allow read, list: if request.auth != null && request.auth.uid == userId;
        allow update, delete: if false;
      }

      match /my_recipes/{recipeId} {
        allow read, list: if request.auth != null && request.auth.uid == userId;
        
        // Allow client writes with basic validation - recipes can be created/edited by the user
        allow create, update: if request.auth != null &&
                              request.auth.uid == userId &&
                              // Basic security checks - user owns the recipe
                              request.resource.data.createdByUserId == request.auth.uid &&
                              request.resource.data.recipeId == recipeId &&
                              // Basic content validation - must have a title
                              request.resource.data.title is string &&
                              request.resource.data.title.size() > 0;
        
        // Fallback: Allow backend cloud functions to write without strict validation
        // This covers cases where the backend needs to save recipes that might not meet client validation
        allow write: if request.auth != null &&
                       request.auth.uid == userId;
        
        allow delete: if request.auth != null && request.auth.uid == userId;
      }

      match /cook_log/{logId} {
        allow read, list: if request.auth != null && request.auth.uid == userId;
        allow create: if request.auth != null && request.auth.uid == userId &&
                        request.resource.data.recipeId is string &&
                        request.resource.data.cookedDate == request.time;
        allow update, delete: if false;
      }

      match /chapters/{chapterId} {
        allow read, list: if request.auth != null && request.auth.uid == userId;
        allow create: if request.auth != null && request.auth.uid == userId &&
                        request.resource.data.name is string &&
                        request.resource.data.name.size() > 0;
        allow update: if request.auth != null && request.auth.uid == userId;
        allow delete: if request.auth != null && request.auth.uid == userId;

        match /recipes/{recipeIdInChapter} {
          allow read, list: if request.auth != null && request.auth.uid == userId;
          allow create: if request.auth != null && request.auth.uid == userId &&
                              request.resource.data.addedDate == request.time && // Ensure addedDate is server timestamp
                              request.resource.data.title is string && // Example: Ensure title is a string
                              request.resource.data.title.size() > 0;
                              // Add other necessary field validations for recipe creation here
          allow delete: if request.auth != null && request.auth.uid == userId;
          allow update: if request.auth != null && request.auth.uid == userId &&
                              request.resource.data.title is string && // Example: Ensure title is a string on update
                              request.resource.data.title.size() > 0 &&
                              // Ensure critical fields like createdByUserId or original recipeId are not changed if they exist
                              (!('createdByUserId' in request.resource.data) || request.resource.data.createdByUserId == resource.data.createdByUserId) &&
                              // Add other necessary field validations for recipe updates here
                              // For example, if 'addedDate' should be immutable:
                              (!('addedDate' in request.resource.data) || request.resource.data.addedDate == resource.data.addedDate);
        }
      }

      match /view_history/{historyRecipeId} {
        allow read, list: if request.auth != null && request.auth.uid == userId;
        // Allow create/update for view history (e.g., update viewedAt)
        allow create, update: if request.auth != null && request.auth.uid == userId &&
                                request.resource.data.recipeTitle is string &&
                                request.resource.data.viewedAt == request.time; // Or allow client-set timestamp if needed with validation
        allow delete: if false; // Users typically don't delete view history
      }

      match /following/{followedUserId} {
        allow read, list: if request.auth.uid == userId;
        allow create: if request.auth.uid == userId &&
                        request.resource.data.username is string &&
                        request.resource.data.followedAt == request.time;
        allow delete: if request.auth.uid == userId;
        allow update: if false;
      }

      match /followers/{followerUserId} {
        allow read, list: if request.auth != null;
        allow create: if request.auth.uid == followerUserId &&
                        request.resource.data.username is string &&
                        request.resource.data.followedAt == request.time;
        allow delete: if request.auth.uid == followerUserId;
        allow update: if false;
      }

      // Rule for Meal Plan Preferences subcollection
      match /mealPlanPreferences/{docId} {
        allow read: if request.auth != null && request.auth.uid == userId;
        // Allow create and update only if the user is authenticated and it's their own document
        // and the document ID is 'userPreferences'
        allow write: if request.auth != null && 
                        request.auth.uid == userId &&
                        docId == "userPreferences" &&
                        // Start of Data Validation (add more specific checks based on MealPlanPreferences model)
                        (request.resource.data.macroTargets is map || request.resource.data.macroTargets == null) &&
                        (request.resource.data.macroTargets.calories is number || request.resource.data.macroTargets.calories == null) && 
                        // Add similar checks for protein, carbs, fat
                        (request.resource.data.availableCookingDays is list || request.resource.data.availableCookingDays == null) &&
                        // For each item in availableCookingDays, ensure it's a string (if needed)
                        (request.resource.data.planDurationWeeks is number || request.resource.data.planDurationWeeks == null) &&
                        (request.resource.data.includeBreakfast is bool || request.resource.data.includeBreakfast == null) &&
                        (request.resource.data.includeLunch is bool || request.resource.data.includeLunch == null) &&
                        (request.resource.data.includeDinner is bool || request.resource.data.includeDinner == null) &&
                        (request.resource.data.cookTimePreference is string || request.resource.data.cookTimePreference == null) && // Assuming CookTimePreference.rawValue is String
                        // Validate enums like cookingExperience, recipeSourcePriority, prepVolume similarly based on their rawValue types
                        (request.resource.data.updatedAtServerTimestamp == request.time) && // Server timestamp must be set by server
                        // Ensure no unexpected fields are written
                        request.resource.data.keys().hasOnly([
                            'macroTargets', 'availableCookingDays', 'age', 'gender', 'weightKg', 'activityLevel',
                            'mealPlanObjectives', 'dietaryPreferences', 'allergies', 'preferredCuisines',
                            'recipeSourcePriority', 'cookingExperience', 'planDurationWeeks', 'targetEventDate',
                            'availableKitchenTools', 'prepVolume', 'includeBreakfast', 'includeLunch', 'includeDinner',
                            'cookTimePreference', 'updatedAt', 'updatedAtServerTimestamp' // 'updatedAt' might be client-set ISO string
                        ]);
        // allow delete: if false; // Or allow if needed
      }
    } // END of /users/{userId} block

    match /usernames/{usernameDocId} {
      allow get: if request.auth != null;
      // Allow create only if the username doesn't exist yet (checked by !exists)
      // and the userId in the document matches the authenticated user.
      allow create: if request.auth != null &&
                        request.resource.data.userId == request.auth.uid &&
                        !exists(/databases/$(database)/documents/usernames/$(usernameDocId)) &&
                        request.resource.data.createdAt == request.time;
      // Allow delete only if the userId in the existing document matches the authenticated user.
      allow delete: if request.auth != null &&
                        resource.data.userId == request.auth.uid;
      allow list: if false; // Not typically needed to list all usernames
      allow update: if false; // Usernames are typically created/deleted, not updated in place by client
    }

    match /public_recipes/{recipeId} {
      allow read: if request.auth != null; // Allow any authenticated user to read public recipes
      allow write: if false; // Public recipes are written via Cloud Functions or Admin SDK

      match /reviews/{reviewUserId} {
        allow read, list: if request.auth != null;
        allow create: if request.auth != null &&
                        request.auth.uid == reviewUserId && // User can only create their own review
                        request.resource.data.userId == request.auth.uid &&
                        request.resource.data.rating is number &&
                        request.resource.data.rating >= 1 && request.resource.data.rating <= 5 &&
                        request.resource.data.timestamp == request.time && // Use server timestamp for review creation
                        (!('reviewText' in request.resource.data) || request.resource.data.reviewText is string || request.resource.data.reviewText == null);

        allow update: if request.auth != null &&
                        request.auth.uid == reviewUserId && // User can only update their own review
                        resource.data.userId == request.auth.uid && // Check existing resource
                        request.resource.data.userId == request.auth.uid && // Check incoming data
                        request.resource.data.rating is number &&
                        request.resource.data.rating >= 1 && request.resource.data.rating <= 5 &&
                        request.resource.data.timestamp == request.time && // Allow timestamp update on review edit
                        (!('reviewText' in request.resource.data) || request.resource.data.reviewText is string || request.resource.data.reviewText == null) &&
                        request.resource.data.keys().hasOnly(['userId', 'rating', 'timestamp', 'reviewText']);

        allow delete: if request.auth != null &&
                        request.auth.uid == reviewUserId && // User can only delete their own review
                        resource.data.userId == request.auth.uid;
      }
    }

    match /shared_recipes/{shareId} {
      allow read: if true; // Shared recipes are public for a short time via unique ID
      allow write: if false; // Created via Cloud Function or trusted server
    }

    match /leaderboard_definitions/{definitionId} {
      allow read: if request.auth != null; // Authenticated users can read these for discovery
      allow write: if false; // Admin only
    }

    match /recipeSaves/{saveEntryId} {
      allow read, write: if false; // No direct client access, managed by Cloud Functions
    }

    match /recipes/{recipeId} {
      allow read: if request.auth != null || (resource.data.isPublic != null && resource.data.isPublic == true);
      allow write: if false; // Typically managed by Cloud Functions or admin
    }

    // === Feedback Submissions ===
    match /feedback_submissions/{feedbackId} {
      allow create: if (request.auth != null && (request.resource.data.userId == request.auth.uid || request.resource.data.userId == null)) || request.auth == null && // Allow authenticated users to submit for themselves or anonymously, OR allow fully anonymous submissions
                      request.resource.data.feedbackType is string &&
                      request.resource.data.description is string &&
                      request.resource.data.description.size() > 0 &&
                      request.resource.data.timestamp is timestamp && // Allow client-set timestamp for feedback
                      request.resource.data.status == "new" &&
                      (!('username' in request.resource.data) || request.resource.data.username is string || request.resource.data.username == null) &&
                      (!('email' in request.resource.data) || request.resource.data.email is string || request.resource.data.email == null) &&
                      (!('affectedFeature' in request.resource.data) || request.resource.data.affectedFeature is string || request.resource.data.affectedFeature == null) &&
                      (!('appVersion' in request.resource.data) || request.resource.data.appVersion is string || request.resource.data.appVersion == null) &&
                      (!('buildNumber' in request.resource.data) || request.resource.data.buildNumber is string || request.resource.data.buildNumber == null) &&
                      (!('deviceModel' in request.resource.data) || request.resource.data.deviceModel is string || request.resource.data.deviceModel == null) &&
                      (!('osVersion' in request.resource.data) || request.resource.data.osVersion is string || request.resource.data.osVersion == null) &&
                      (!('screenshotURLs' in request.resource.data) || request.resource.data.screenshotURLs is list || request.resource.data.screenshotURLs == null) &&
                      request.resource.data.keys().hasOnly([
                        'userId', 'username', 'email', 'feedbackType', 'description',
                        'affectedFeature', 'appVersion', 'buildNumber', 'deviceModel',
                        'osVersion', 'screenshotURLs', 'timestamp', 'status'
                      ]);
      allow read, update, delete: if false;
    }

    // === Onboarding Tours ===
    match /onboarding_tours/{tourDocId} {
      allow read: if request.auth != null; // Allow any authenticated user to read onboarding tours
      allow write: if false; // For now, prevent client-side writes (admin only)
    }

  } // END of /databases/{database}/documents block
} // END of service cloud.firestore